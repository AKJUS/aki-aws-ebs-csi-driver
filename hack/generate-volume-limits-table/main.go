// Copyright 2025 The Kubernetes Authors.
//
// Licensed under the Apache License, Version 2.0 (the 'License');
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"context"
	"log"
	"os"
	"sort"
	"text/template"
	"time"

	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/service/ec2"
	"github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/util"
)

const (
	timeout       = 5 * time.Minute
	hypervisorXen = "xen"
)

type instanceData struct {
	MaxAttachments int32
	AttachmentType string
	Hypervisor     string
}

type templateData struct {
	NonNitroInstances []string
	VolumeLimits      map[string]instanceData
}

const outputTemplate = `// Code generated by hack/generate-volume-limits-table.go. DO NOT EDIT.

package cloud

// nonNitroInstanceTypes contains instance types that have a shared limit of 40 volumes
var nonNitroInstanceTypes = map[string]struct{}{
{{- range .NonNitroInstances}}
	"{{.}}": {},
{{- end}}
}

// volumeLimits contains instance types with non-standard volume limits
// non-nitro instances, and nitro instances with the default limit (shared 27) are excluded
var volumeLimits = map[string]volumeLimit{
{{- range $instanceType, $data := .VolumeLimits}}
	"{{$instanceType}}": { {{$data.MaxAttachments}}, "{{$data.AttachmentType}}" },
{{- end}}
}

type volumeLimit struct {
	maxAttachments int
	attachmentType string
}
`

func getAvailableRegions(ctx context.Context) ([]string, error) {
	cfg, err := config.LoadDefaultConfig(ctx)
	if err != nil {
		return nil, err
	}

	ec2Client := ec2.NewFromConfig(cfg)
	result, err := ec2Client.DescribeRegions(ctx, &ec2.DescribeRegionsInput{})
	if err != nil {
		return nil, err
	}

	regions := make([]string, 0, len(result.Regions))
	for _, region := range result.Regions {
		regions = append(regions, *region.RegionName)
	}

	return regions, nil
}

func getInstanceTypesForRegion(ctx context.Context, region string) (map[string]instanceData, error) {
	cfg, err := config.LoadDefaultConfig(ctx, config.WithRegion(region))
	if err != nil {
		return nil, err
	}
	ec2Client := ec2.NewFromConfig(cfg)

	instances := make(map[string]instanceData)
	paginator := ec2.NewDescribeInstanceTypesPaginator(ec2Client, &ec2.DescribeInstanceTypesInput{})

	for paginator.HasMorePages() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, instanceType := range page.InstanceTypes {
			switch {
			case string(instanceType.InstanceType) == "":
				log.Fatalf("InstanceType should never be empty")
			case instanceType.EbsInfo == nil:
				log.Fatalf("EbsInfo should never be nil for instance type %s", instanceType.InstanceType)
			case instanceType.EbsInfo.MaximumEbsAttachments == nil:
				log.Fatalf("MaximumEbsAttachments should never be nil for instance type %s", instanceType.InstanceType)
			case instanceType.EbsInfo.AttachmentLimitType != util.AttachmentDedicated && instanceType.EbsInfo.AttachmentLimitType != util.AttachmentShared:
				log.Fatalf("AttachmentLimitType is invalid value %s for instance type %s", instanceType.InstanceType, instanceType.EbsInfo.AttachmentLimitType)
			}

			key := string(instanceType.InstanceType)
			instances[key] = instanceData{
				MaxAttachments: *instanceType.EbsInfo.MaximumEbsAttachments,
				AttachmentType: string(instanceType.EbsInfo.AttachmentLimitType),
				Hypervisor:     string(instanceType.Hypervisor),
			}
		}
	}

	return instances, nil
}

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel()

	// Discover available regions
	regions, err := getAvailableRegions(ctx)
	if err != nil {
		log.Printf("Failed to discover regions: %v", err)
		return
	}

	log.Printf("Discovered %d regions", len(regions))

	// Collect instance data from regions
	allInstances := make(map[string]instanceData)

	for _, region := range regions {
		log.Printf("Getting volume limits for %s...", region)

		instances, err := getInstanceTypesForRegion(ctx, region)
		if err != nil {
			log.Printf("Error getting instance types for %s: %v", region, err)
			continue
		}

		// Merge instances, checking for conflicts
		for k, v := range instances {
			if existing, exists := allInstances[k]; exists {
				if existing.MaxAttachments != v.MaxAttachments || existing.AttachmentType != v.AttachmentType || existing.Hypervisor != v.Hypervisor {
					//nolint:gocritic // Safe to Fatal here because defer is unimportant
					log.Fatalf("Instance type %s has different limits in different regions: %+v vs %+v", k, existing, v)
				}
			}
			allInstances[k] = v
		}
	}

	if len(allInstances) == 0 {
		log.Print("No instance types found")
		return
	}

	log.Printf("Found %d unique instance types", len(allInstances))

	// Process data
	var nonNitroInstances []string
	volumeLimits := make(map[string]instanceData)

	for instanceType, instance := range allInstances {
		if instance.Hypervisor == hypervisorXen {
			nonNitroInstances = append(nonNitroInstances, instanceType)
		} else if instance.MaxAttachments != 27 || instance.AttachmentType != util.AttachmentShared {
			volumeLimits[instanceType] = instance
		}
	}

	sort.Strings(nonNitroInstances)

	// Generate output to stdout
	tmpl, err := template.New("output").Parse(outputTemplate)
	if err != nil {
		log.Printf("Failed to parse template: %v", err)
		return
	}

	data := templateData{
		NonNitroInstances: nonNitroInstances,
		VolumeLimits:      volumeLimits,
	}

	err = tmpl.Execute(os.Stdout, data)
	if err != nil {
		log.Printf("Failed to execute template: %v", err)
		return
	}

	log.Print("Generated volume limits table")
}
